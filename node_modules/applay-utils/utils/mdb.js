var MongoBase = require('mongodb');
var ObjectId = require('mongodb').ObjectId;
var ObjectID = ObjectId;

var MDB = {
  status: {},
  clients: {}
}

var connect = (alias, url, callback) => {
  // console.log('Conectando..', alias, ' - url:', url);
  if (MDB.status[alias]) { return callback(MDB.clients[alias]); }
  MongoBase.MongoClient.connect(url, { useUnifiedTopology: true }, (err, client) => {
    if (err) { return console.log('ERRO MDB -- TRACKING -- ', err); }
    MDB.status[alias] = true;
    MDB.clients[alias] = client;
    process.on('SIGTERM', internalStop(alias, true, 'SIGTERM'));
    process.on('SIGINT', internalStop(alias, true, 'SIGINT'));
    process.on('uncaughtException', internalStop(alias, true, 'uncaughtException'));
    // console.log('Conectado com ', alias);
    callback(client)
  });
}

var connectAsync = (alias, url) => new Promise(resolve => connect(alias, url, (client) => resolve(client)));

var internalStop = (alias, finish) => {
  return (code) => {
    // console.log('Desconnecting...');
    if (!MDB.status[alias]) { console.log('Mongodb OFF'); return }
    MDB.status[alias] = false;
    MDB.clients[alias].close();
    if (finish && MDB.stopCustom) {
      MDB.stop(alias, () => {
        console.log('Mongodb', alias, 'OFF');
        setTimeout(() => { process.exit(); },100)
      });
    }
    if (finish && !MDB.stopCustom) {
      console.log('Mongodb', alias, 'OFF');
      setTimeout(() => { process.exit(); }, 100)
    }
    if (!finish) {
      console.log('Mongodb', alias, 'OFF');
    }
  }

}


var stopCustom = (customCallback) => {
  MDB.stopCustom = true;
  MDB.stop = customCallback;//(alias,callback)=>{}
}

var genOpsUpdate = (data, params) => {
  var lista = [];

  for (var item of data) {
    let filter = item.filter;
    let update = item.update;

    var novo = params && params.newField && item[params.newField];
    var remove = params && params.removeField && item[params.removeField];

    if (params && params.type == 'array') {
      let objArray = {}
      let sub = params.rule.split('.');

      update = {};

      if (novo) {
        delete item[params.newField];
        update[sub[0]] = item;
      }
      else if (remove) {
        delete item[params.removeField];
        objArray[params.rule] = item[sub[1]];
        let objRemove = {};
        objRemove[sub[1]] = item[sub[1]];
        update[sub[0]] = objRemove;
      }
      else {
        objArray[params.rule] = item[sub[1]];
        update[sub[0] + '.$'] = item;
      }

      filter = Object.assign(objArray, params.filter)
    }

    let objLista = {}
    var upSet = { $set: update };

    if (novo) {
      upSet = { $addToSet: update };
    }
    else if (remove) {
      upSet = { $pull: update };
    }

    objLista['updateOne'] = {
      filter: filter,
      update: upSet
    }

    lista.push(objLista)
  }
  return lista
}

function genOpsFull(data, tipo) {
  var lista = [];
  for (var x1 in data) {
    var objLista = {};
    if (typeof data[x1] != 'object') { continue; }
    if (tipo == 'save' && !data[x1]._id) {
      objLista['insertOne'] = { document: data[x1] };
    }
    if (tipo == 'save' && data[x1]._id && (data[x1]._id + '').length == 24) {
      data[x1]._id = new ObjectID(data[x1]._id + '');

      objLista['replaceOne'] = {
        filter: { "_id": data[x1]._id },
        replacement: data[x1],
        upsert: true
      }
    }
    if (tipo == 'reg' || tipo == 'regs') {
      var copyObj = Object.assign({}, data[x1]);
      copyObj.regId = ''

      if (data[x1]._id) { copyObj._reg.objId = data[x1]._id + ''; }

      delete copyObj._id;

      objLista['insertOne'] = { document: copyObj };
    }

    lista.push(objLista);
  }
  return lista;
}


function genOps(data, tipo) {
  var lista = [];
  var regs = [];
  for (var x1 in data) {
    var objLista = {};
    if (typeof data[x1] != 'object') { continue; }
    if (tipo == 'insert' && data[x1]._id) { continue; }
    if (tipo == 'replace' && !data[x1]._id) { continue; }
    if (tipo == 'insert') { objLista['insertOne'] = { document: data[x1] }; }
    if (tipo == 'replace') {
      data[x1]._id = new ObjectID(data[x1]._id + '');
      objLista['replaceOne'] = {
        filter: { "_id": data[x1]._id },
        replacement: data[x1],
        upsert: true
      }
    }
    if (tipo == 'regs') {
      var copyObj = Object.assign({}, data[x1]);;
      copyObj.regId = ''
      if (data[x1]._id) { copyObj._reg.objId = data[x1]._id + ''; }
      delete copyObj._id;
      objLista['insertOne'] = { document: copyObj };
    }
    lista.push(objLista);
  }
  return lista;
}

function build(data, model, user) {
  var tipo = model.slice(0, 3);
  var time = new Date();
  var letra = model.slice(3, 4);
  // if(cfg.db.types.indexOf(tipo)<0){return {status:false,msg:'Tipo de Collection não definida'};}
  if ('ABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(letra) < 0) { return { status: false, msg: 'Tipo de Collection não definida' }; }
  for (var x1 in data) {
    // console.log(x1,data[x1]);
    var create = time.getTime();
    var createtext = time.toLocaleString('pt-BR');
    if (data[x1]._db) {
      create = data[x1]._db.create * 1;
      createtext = data[x1]._db.createtext + '';
    }
    data[x1]._db = {
      tipo: tipo,
      time: time.getTime(),
      timetext: time.toLocaleString('pt-BR').split(' ')[0],
      create: create * 1,
      createtext: createtext + '',
      userId: user._id + '',
      username: user.username
    };
    // var objId = data[x1]._reg && data[x1]._reg.objId ? data[x1]._reg.objId : '';
    var objId = data[x1]._id ? data[x1]._id + '' : (data[x1]._reg && data[x1]._reg.objId ? data[x1]._reg.objId : '');
    data[x1]._reg = {
      regId: time.getTime() + user._id + '',
      collection: model,
      objId: objId,
      reg: 'reg' + model.slice(0, 1).toUpperCase() + model.slice(1)
    };
  }
  return data;
}

module.exports = {
  ObjectId,
  ObjectID,
  connect,
  connectAsync,
  stopCustom,
  build,
  genOps,
  genOpsFull,
  genOpsUpdate
};
