const mdb = require('./mdb');

var querys = {
  'findAsync': (db, collection, filter, fields) => new Promise(resolve => db.collection(collection).find(filter, fields).toArray((err, result) => resolve(result))),
  'findOneAsync': (db, collection, filter, fields) => new Promise(resolve => db.collection(collection).findOne(filter, fields, (err, result) => resolve(result))),
  'findOneMapAsync': (db, collection, param) => new Promise(resolve => {
    if (!param || typeof param.rule != 'string' || param.rule.split('.').length != 2 || !Array.isArray(param.list)) {
      // return resolve({ status: false, err: 'param deve ser parecido {filter:{},rule:"lista.codigo",list:[],project:{}}' });
      console.log(`Erro findOneMapAsync: param deve ser parecido { filter: {}, rule: "lista.codigo", list: [], project: {} }`);
      return resolve(null);
    }

    var fieldLista = param.rule.split('.')[0];
    var fieldItem = param.rule.split('.')[1];

    var projectAuto = {}

    projectAuto[fieldLista] = {
      $filter: {
        input: '$' + fieldLista,
        as: 'item',
        cond: {
          $in: [
            "$$item." + fieldItem,
            param.list || []
          ]
        }
      }
    }

    db.collection(collection).aggregate([
      { $match: param.filter || {} },
      { $project: Object.assign(projectAuto, param.project || {}) }
    ]).toArray((err, result) => {
      if (err) { console.log('Erro aggregate cad: ', err); }
      resolve(result[0]);
    });
  }),
  'findLimitAsync': (db, collection, filter, limit) => new Promise(resolve => db.collection(collection).find(filter).limit(limit).toArray((err, result) => resolve(result))),
  'distinctAsync': (db, collection, filter, campo) => new Promise(resolve => db.collection(collection).distinct(campo, filter, (err, result) => resolve(result))),
  'findLimitSortAsync': (db, collection, filter, sort, limit) => new Promise(resolve => db.collection(collection).find(filter).sort(sort).limit(limit).toArray((err, result) => resolve(result))),
  'findSortAsync': (db, collection, filter, sort) => new Promise(resolve => db.collection(collection).find(filter).sort(sort).toArray((err, result) => resolve(result))),
  'findTextAsync': (db, collection, filter) => new Promise(resolve => db.collection(collection).find(filter.query).project(filter.score).sort(filter.score).limit(20).toArray((err, result) => resolve(result))),
  'countAsync': (db, collection, filter) => new Promise(resolve => db.collection(collection).countDocuments(filter, (err, result) => resolve(result))),
  'updateAsync': (db, collection, item) => new Promise(resolve => db.collection(collection).replaceOne({ _id: new mdb.ObjectID(item._id) }, item, (err, result) => { if (err) { console.log('erro', err); } return resolve(result); })),
  'insertOneAsync': (db, collection, item) => new Promise(resolve => db.collection(collection).insertOne(item, (err, result) => resolve(result))),
  'insertOne': (db, collection, item) => new Promise(resolve => db.collection(collection).insertOne(item, (err, result) => resolve(result))),
  'insertMany': (db, collection, item) => new Promise(resolve => db.collection(collection).insertMany(item, (err, result) => resolve(result))),
  'findLastAsync': (db, collection, filter) => new Promise(resolve => db.collection(collection).find(filter).sort({ _id: -1 }).limit(1).toArray((err, result) => resolve(result[0]))),
  'updateSetAsync': (db, collection, itemId, itemSet) => new Promise(resolve => db.collection(collection).findOneAndUpdate(itemId, { $set: itemSet }, (err, result) => resolve(result))),
  'updateAllAsync': (db, collection, filter, itemSet) => new Promise(resolve => db.collection(collection).updateMany(filter, itemSet, (err, result) => resolve(err || result))),
  'aggregateAsync': (db, collection, pipe, options) => new Promise(resolve => db.collection(collection).aggregate(pipe, { allowDiskUse: true, ...options }).toArray((err, result) => resolve(result))),
  'deleteMany': (db, collection, filter) => new Promise(resolve => db.collection(collection).deleteMany(filter, (err, result) => resolve(result))),
  'saveAsync': (db, collection, dataOrItem, user) => new Promise(resolve => {
    // console.log("ðŸš€ ~ db", db)
    // console.log("ðŸš€ ~ collection", collection)
    
    var data = Array.isArray(dataOrItem) ? dataOrItem : [dataOrItem];
    // console.log("ðŸš€ ~ data", data)
    var dataBuild = mdb.build(data, collection, user);
    // console.log("ðŸš€ ~ dataBuild", dataBuild)
    var listaOps = mdb.genOpsFull(dataBuild, 'save');
    // console.log("ðŸš€ ~ listaOps", listaOps)

    db.collection(collection).bulkWrite(listaOps, (err, result) => {
      if (err) { console.log('Erro bulkwrite cad: ', err); }

      var ids = result.getInsertedIds();
      ids.forEach(e => dataBuild[e.index]._reg.objId = e._id + '');

      var regsOps = mdb.genOpsFull(dataBuild, 'reg');
      var regCollection = 'reg' + collection.slice(0, 1).toUpperCase() + collection.slice(1);

      db.collection(regCollection).bulkWrite(regsOps, (err2, result2) => {
        if (err2) { console.log('Erro bulkwrite reg: ', err2); }

        var resObj = { ids: ids, regs: result2 }

        resolve(resObj);
      });
    });

  }),
  'updateFilterAsync': (db, collection, data, param) => new Promise(resolve => {
    var listaOps = mdb.genOpsUpdate(data, param);
    // console.log(listaOps)
    db.collection(collection).bulkWrite(listaOps, (err, result) => {
      if (err) { console.log('Erro bulkwrite cad: ', err); }
      var result = result.result;
      resolve({ status: true, result });
    });
  }),
  'updateManyAsync':(db,collection,data) => new Promise(resolve=>{
    var listaOps = mdb.genOpsFull(data, 'save');
    db.collection(collection).bulkWrite(listaOps, (err, result) => {
      if (err) { console.log('Erro bulkwrite cad: ', err); }
      var ids = result.getInsertedIds();
      resolve({status:true,ids:ids});
    });
  }),
  'bulkWriteAsync': (db, collection, item) => new Promise(resolve => db.collection(collection).bulkWrite(item, (err, result) => resolve(err || result)))
}
  
module.exports = querys;
